<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace命名空间,作用就是对sql进行分类化的管理,理解为sql隔离
	注意:使用mapper代理开发时，namespace有特殊作用
-->
<mapper namespace="poem">
	<select id="findPoemById" parameterType="int" resultMap="poem.poemMap">
		select * from poem where id=#{id}
	</select>

	<!-- 根据用户名称模糊查询用户信息,可能返回多条数据
		resultType:指定的就是单条记录所映射的java类型;
		${}:表示拼接sql字符串，将接收到的参数内容不加任何修饰拼接在sql中.
		使用${}拼接sql，可能会引起sql注入
		${value}:接收输入参数的内容，如果传入的是简单类型,${}中只能使用value
	-->
	<!-- <select id="findUserByName" parameterType="java.lang.String" -->
	<!-- resultType="com.mybatis.entity.User"> -->
	<!-- select * from t_user where username LIKE '%${value}%' -->
	<!-- </select> -->
	<!-- 添加用户
		parameterType:指定输入的参数类型是pojo(包括用户信息);
		#{}中指定pojo的属性名称，接收到pojo对象的属性值 ,mybatis通过OGNL(类似struts2的OGNL)获取对象的属性值
	-->

	<insert id="insertPoem" parameterType="com.poem.lld.model.Poem">
		<selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
			select last_insert_rowid() from poem limit 1
		</selectKey>
		insert into poem (title, author, content, album, `type`, url, public_degree, dynasty)
		values(#{title}, #{author}, #{content}, #{album}, #{type}, #{url}, #{publicDegree}, #{dynasty})
	</insert>

	<delete id="deletePoem" parameterType="java.lang.Integer">
		delete from poem where id=#{id}
	</delete>

	<update id="updatePoem" parameterType="com.poem.lld.model.Poem">
		update poem
		set title = #{title}, author = #{author}, content = #{content}, album = #{album},
			`type` = #{type}, url = #{url}, public_degree = #{publicDegree}, dynasty = #{dynasty} 
		where id=#{id}
	</update>

</mapper>
